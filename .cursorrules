# Flutter Bloc Guidelines (Without Freezed)

## ğŸ§  State Management (Bloc/Cubit)

### General Principles
- Use **Cubit** for simple UI state (e.g., toggles, filters).
- Use **Bloc** for complex logic involving multiple events.
- Prefer single `State` classes with `copyWith` methods instead of Freezed.
- Always keep Bloc/Cubit classes focusedâ€”extract logic into services/helpers.

### State Class (Example)
```dart
class CounterState {
  final int count;
  final bool isLoading;
  final String? error;

  const CounterState({
    required this.count,
    this.isLoading = false,
    this.error,
  });

  CounterState copyWith({
    int? count,
    bool? isLoading,
    String? error,
  }) {
    return CounterState(
      count: count ?? this.count,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}
```

### Bloc Best Practices
- Always initialize the state in the constructor.
- Avoid unnecessary rebuilds by selecting specific slices of state.
- Use `BlocBuilder` for building UI and `BlocListener` for side-effects.
- Use descriptive event names: `LoadUserProfile`, `SubmitForm`, etc.
- Handle error and loading states explicitly inside Bloc logic.

## ğŸ“¦ File Structure
```
lib/
â””â”€â”€ core/
    â”œâ”€â”€ config/               # Global configs (environment, constants, secrets)
    â”œâ”€â”€ errors/               # Global error classes/exceptions
    â”œâ”€â”€ platform/             # Platform-specific integrations (native channels)
    â”œâ”€â”€ router/               # GoRouter or other navigation setup
    â”œâ”€â”€ theme/                # ThemeData, color schemes, text styles
    â”œâ”€â”€ usecases/             # (Optional) Global use cases that span multiple features
    â””â”€â”€ utils/                # Helpers, extensions, converters, formatters

â””â”€â”€ features/
    â”œâ”€â”€ authentication/
    â”‚   â”œâ”€â”€ data/
    â”‚   â”‚   â”œâ”€â”€ datasources/  # Remote/local data fetch
    â”‚   â”‚   â”œâ”€â”€ models/       # DTOs or raw data structures
    â”‚   â”‚   â””â”€â”€ repositories/ # Repository implementations
    â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚   â”œâ”€â”€ entities/     # Core business objects
    â”‚   â”‚   â””â”€â”€ repositories/ # Abstract repository contracts
    â”‚   â”œâ”€â”€ presentation/
    â”‚   â”‚   â”œâ”€â”€ blocs/        # Cubit/Bloc classes for Auth
    â”‚   â”‚   â”œâ”€â”€ pages/        # Screens for login, register, forgot password
    â”‚   â”‚   â””â”€â”€ widgets/      # Reusable UI components
    â”‚   â””â”€â”€ usecases/         # Business logic for auth flow
    â”œâ”€â”€ home/
    â”‚   â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ domain/
    â”‚   â”œâ”€â”€ presentation/
    â”‚   â””â”€â”€ usecases/
    â”œâ”€â”€ recipe/
    â”‚   â”œâ”€â”€ data/
    â”‚   â”‚   â”œâ”€â”€ datasources/
    â”‚   â”‚   â”œâ”€â”€ models/
    â”‚   â”‚   â””â”€â”€ repositories/
    â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚   â”œâ”€â”€ entities/
    â”‚   â”‚   â””â”€â”€ repositories/
    â”‚   â”œâ”€â”€ presentation/
    â”‚   â”‚   â”œâ”€â”€ blocs/        # e.g. RecipeBloc, RecipeCubit
    â”‚   â”‚   â”œâ”€â”€ pages/        # e.g. RecipeListPage, RecipeDetailPage
    â”‚   â”‚   â””â”€â”€ widgets/      # e.g. RecipeCard, IngredientInput
    â”‚   â””â”€â”€ usecases/         # Recipe CRUD logic, generation, etc.
    â”œâ”€â”€ settings/
    â”‚   â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ domain/
    â”‚   â”œâ”€â”€ presentation/
    â”‚   â””â”€â”€ usecases/
    â””â”€â”€ ... more features ...
    
â””â”€â”€ shared/
    â”œâ”€â”€ services/             # Reusable cross-feature services (e.g., analytics, push notifications)
    â”œâ”€â”€ widgets/              # Reusable UI components used in multiple features
    â””â”€â”€ packages/             # Sub-packages or modules for separation of concerns (optional)
â””â”€â”€ bootstrap.dart      # inisiliztion separation 
â””â”€â”€ main.dart                 # Entry point of the application

```

## ğŸ§± Reusable Widgets Guidelines
- Create modular, composable UI components.
- Use `@immutable` stateless widgets when possible.
- Separate UI logic into smaller widgets with customization via parameters.
- Make all widgets configurable and styled via `ThemeData`.
- Prefer `extension` methods or `Theme.of(context).x` for dynamic theming.

### Example Themed Widget
```dart
class AppButton extends StatelessWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isLoading;

  const AppButton({
    required this.label,
    required this.onPressed,
    this.isLoading = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return ElevatedButton(
      style: ElevatedButton.styleFrom(
        backgroundColor: theme.colorScheme.primary,
      ),
      onPressed: isLoading ? null : onPressed,
      child: isLoading
          ? const CircularProgressIndicator()
          : Text(label, style: theme.textTheme.labelLarge),
    );
  }
}
```

## ğŸ”’ Firebase Integration Best Practices
- Use Firebase Auth for sign-in, sign-up, password reset.
- Store structured, normalized data in Firestore.
- Use `createdAt`, `updatedAt`, and `isDeleted` fields.
- Secure your Firestore rules by user roles and permissions.
- Use Firebase Storage for media and Firebase Analytics for tracking.

## âš™ï¸ Theming & Styling
- Define all colors, spacings, text styles in `ThemeData`.
- Prefer `Theme.of(context).textTheme.titleLarge` over deprecated styles.
- Support dark/light themes via `ThemeMode.system`.
- Use `MediaQuery`/`LayoutBuilder` for responsiveness.

## ğŸ“ˆ Performance
- Use `const` constructors as much as possible.
- Use `ListView.builder` for long lists.
- Optimize Firebase queries: index fields, paginate results.
- Use `cached_network_image` for remote images.

## ğŸ§ª Testing
- Write unit tests for Cubits and Blocs.
- Use `mocktail` or `mockito` for dependencies.
- Widget test reusable widgets.

## ğŸ” Navigation
- Use `GoRouter` or `auto_route`.
- Handle deep links with custom routes.
- Keep routes organized per feature.

## ğŸ“¦ Code Generation
- Avoid `freezed`, prefer manually written copyWith and equality.
- Use `json_serializable` for models.
- Run:
```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

## ğŸ”§ Miscellaneous
- Use `log()` over `print()` for debugging.
- Use `BlocObserver` to log transitions.
- Follow Dart style guide (80 char line limit, trailing commas).
- Create enums using `@JsonValue()` if storing in Firestore.

## ğŸ“ Documentation
- Add inline comments for non-obvious logic.
- Document business logic flows in bloc files.
- Keep README.md and codebase docs up to date.

---
Follow these principles for building high-quality, production-ready Flutter apps using Bloc and Firebase without Freezed. 